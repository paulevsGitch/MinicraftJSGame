const Entities={};Entities.mutableBox=new BoundingBox(new Vec2(1));class Entity{constructor(){this.lastPosition=new Vec2,this.position=new Vec2,this.boundingBox=new BoundingBox(new Vec2(1)),this.collidable=!1,this.selected=!1,this.alive=!0,this.visible=!0}render(a){}renderSelected(a){a.globalCompositeOperation="destination-out";let b=this.position.x,c=this.position.y;MathHelper.neighbours4.forEach(d=>{this.position.set(b+.0625*d.x,c+.0625*d.y),this.render(a)}),Render.defaultBlending(a),this.position.set(b,c),this.render(a)}tick(a,b){}canMove(a){return void 0!=a&&a!=Tiles.water}onDeath(a){}onCollide(a){}}class StaticEntity extends Entity{constructor(a,b){super(),this.position.set(MathHelper.clampFloat(a,16),MathHelper.clampFloat(b,16))}}class MovableEntity extends Entity{constructor(){super(),this.bbOffset=new Vec2(-0.5),this.colliders=new List,this.collideVelocity=new Vec2,this.velocity=new Vec2,this.speed=5}tick(c,h){this.boundingBox.position.set(this.position).add(this.bbOffset),this.velocity.normalize().multiply(h*this.speed);let i=Math.floor(this.position.x),j=Math.floor(this.position.y);this.colliders.clear();let d=this.velocity.x,e=this.velocity.y;this.boundingBox.position.add(d,e);for(let a=-1;a<=1;a++){let f=i+a;for(let b=-1;b<=1;b++){let g=j+b;!this.canMove(c.getTile(f,g))&&(Entities.mutableBox.position.set(f,g),this.boundingBox.collides(Entities.mutableBox)&&this.colliders.add(structuredClone(Entities.mutableBox)))}}c.visibleEntities.forEach(a=>{a!=this&&2>Math.abs(a.position.x-this.position.x)&&2>Math.abs(a.position.y-this.position.y)&&this.boundingBox.collides(a.boundingBox)&&(a.collidable&&this.colliders.add(a.boundingBox),a.onCollide(this))}),this.boundingBox.position.subtract(d,e),this.colliders.sort((c,d)=>{let a=c.position.x+.5*c.size.x-this.position.x,b=c.position.y+.5*c.size.y-this.position.y,e=a*a+b*b;return a=d.position.x+.5*d.size.x-this.position.x,b=d.position.y+.5*d.size.y-this.position.y,Math.sign(e-(a*a+b*b))}),this.colliders.forEach(a=>this.boundingBox.sweptCollision(a,this.velocity)),this.lastPosition.set(this.position),this.position.add(this.velocity),this.boundingBox.position.set(this.position).add(this.bbOffset)}render(a){a.strokeStyle="magenta",a.beginPath(),a.rect(16*this.boundingBox.position.x,16*this.boundingBox.position.y,16*this.boundingBox.size.x,16*this.boundingBox.size.y),a.stroke()}}const EntityTextures={player:Images.load("img/sprites/player.png")};class PlayerEntity extends MovableEntity{constructor(){super(),this.colliders=new List,this.bbOffset=new Vec2(-0.25),this.boundingBox.size.set(.5),this.speed=3,this.spriteX=0,this.spriteY=0}tick(a,b){this.velocity.set(0,0),Controls.isKeyHold("KeyW")&&(this.velocity.y-=1),Controls.isKeyHold("KeyS")&&(this.velocity.y+=1),Controls.isKeyHold("KeyA")&&(this.velocity.x-=1),Controls.isKeyHold("KeyD")&&(this.velocity.x+=1),super.tick(a,b)}render(b){if(0!=this.velocity.x||0!=this.velocity.y){let a=Math.abs(this.velocity.x),c=Math.abs(this.velocity.y),d=Math.max(a,c);d==a?(this.spriteX=this.velocity.x>0?32:48,this.spriteY=32*Math.floor(3*this.position.x%4)):(this.spriteX=this.velocity.y>0?0:16,this.spriteY=32*Math.floor(3*this.position.y%4))}else this.spriteY=0;b.drawImage(EntityTextures.player,this.spriteX,this.spriteY,16,32,16*this.position.x-8,16*this.position.y-32,16,32)}onCollide(a){a instanceof ItemEntity&&a.canPick&&(a.alive=!1)}}